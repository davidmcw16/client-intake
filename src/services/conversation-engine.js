const llm = require('./llm');
const { getSystemPrompt } = require('../prompts/system-prompt');
const sessionManager = require('./session-manager');
const markdownBuilder = require('./markdown-builder');

const FALLBACK_QUESTIONS = [
  "What's your name, and what do you want to build?",
  "Who would use this, and what problem does it solve for them?",
  "What are the 2-3 must-have features for launch?",
  "Walk me through what a typical user would do step by step.",
  "How should it look and feel? Modern? Playful? Professional?",
  "Does it need to connect to any other tools or services?",
  "Roughly how many people do you expect to use it?",
  "Any timeline, budget, or platform preferences?"
];

const FALLBACK_CATEGORIES = [
  'vision', 'users_problem', 'core_features', 'user_journey',
  'look_feel', 'integrations', 'scale', 'constraints'
];

function generateFallbackBrief(session) {
  var answers = session.fallbackAnswers || [];
  var categories = ['Vision', 'Problem & Users', 'Core Features', 'User Journey',
                    'Look & Feel', 'Integrations', 'Scale', 'Constraints'];
  var md = '# Project Intake: ' + (session.clientName || 'Client') + ' \u2014 ' + new Date().toISOString().split('T')[0] + '\n\n';
  md += '> Voice intake completed in fallback mode\n\n---\n\n';
  categories.forEach(function (cat, i) {
    md += '## ' + cat + '\n\n' + (answers[i] || 'Not provided') + '\n\n';
  });
  md += '---\n\n## Full Conversation Transcript\n\n';
  session.conversationHistory
    .filter(function (m) { return m.role !== 'system'; })
    .forEach(function (m) {
      md += '[' + (m.role === 'assistant' ? 'AI' : 'Client') + ']: ' + m.content + '\n';
    });
  md += '\n---\n\n*Generated by Voice Intake (fallback mode)*\n';
  return md;
}

function parseResponse(text) {
  try {
    return JSON.parse(text);
  } catch (e) {}

  const fenceMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (fenceMatch) {
    try {
      return JSON.parse(fenceMatch[1].trim());
    } catch (e) {}
  }

  return {
    message: text,
    isComplete: false,
    coveredCategories: [],
    confidence: {},
    clientName: null
  };
}

async function startConversation(sessionId) {
  const session = sessionManager.createSession(sessionId);
  const systemPrompt = getSystemPrompt();

  session.conversationHistory.push({ role: 'system', content: systemPrompt });

  try {
    const rawResponse = await llm.chat(systemPrompt, []);
    const parsed = parseResponse(rawResponse);

    session.conversationHistory.push({ role: 'assistant', content: parsed.message });

    sessionManager.updateSession(sessionId, {
      clientName: parsed.clientName || null,
      coveredCategories: parsed.coveredCategories || [],
      confidence: parsed.confidence || {}
    });

    return { sessionId, message: parsed.message, isComplete: false };
  } catch (err) {
    session.fallbackMode = true;
    session.fallbackIndex = 0;
    session.fallbackAnswers = [];
    var greeting = FALLBACK_QUESTIONS[0];
    session.conversationHistory.push({ role: 'assistant', content: greeting });
    return { sessionId, message: greeting, isComplete: false };
  }
}

async function processMessage(sessionId, userMessage) {
  const session = sessionManager.getSession(sessionId);
  if (!session) throw new Error('Session not found: ' + sessionId);

  session.conversationHistory.push({ role: 'user', content: userMessage });
  session.turnCount++;

  // Fallback mode: use fixed questions instead of LLM
  if (session.fallbackMode) {
    var catIndex = session.fallbackIndex;
    if (catIndex < FALLBACK_CATEGORIES.length) {
      session.fallbackAnswers[catIndex] = userMessage;
      var conf = {};
      conf[FALLBACK_CATEGORIES[catIndex]] = 0.5;
      sessionManager.updateSession(sessionId, { confidence: conf });
    }
    session.fallbackIndex++;

    if (session.fallbackIndex >= FALLBACK_QUESTIONS.length) {
      if (catIndex === 0) session.clientName = userMessage.split(',')[0].trim();
      var markdown = generateFallbackBrief(session);
      await sessionManager.persistSession(sessionId, markdown);
      var doneMsg = "Thanks for sharing all of that! I've put together your project brief.";
      session.conversationHistory.push({ role: 'assistant', content: doneMsg });
      return { message: doneMsg, isComplete: true, turnCount: session.turnCount, coveredCategories: FALLBACK_CATEGORIES, markdown: markdown };
    }

    if (catIndex === 0) session.clientName = userMessage.split(',')[0].trim();
    var nextQuestion = FALLBACK_QUESTIONS[session.fallbackIndex];
    session.conversationHistory.push({ role: 'assistant', content: nextQuestion });
    return { message: nextQuestion, isComplete: false, turnCount: session.turnCount, coveredCategories: FALLBACK_CATEGORIES.slice(0, session.fallbackIndex) };
  }

  const wrapUp = session.turnCount >= 20;
  const systemPrompt = getSystemPrompt({ wrapUp });

  const messages = session.conversationHistory
    .filter(m => m.role !== 'system')
    .map(m => ({ role: m.role, content: m.content }));

  var rawResponse;
  try {
    rawResponse = await llm.chat(systemPrompt, messages);
  } catch (err) {
    if (err.message === 'LLM_TIMEOUT') {
      try {
        rawResponse = await llm.chat(systemPrompt, messages);
      } catch (retryErr) {
        return {
          message: "I'm having trouble thinking right now. Could you try saying that again?",
          isComplete: false,
          turnCount: session.turnCount,
          coveredCategories: session.coveredCategories || []
        };
      }
    } else {
      throw err;
    }
  }

  const parsed = parseResponse(rawResponse);

  session.conversationHistory.push({ role: 'assistant', content: parsed.message });

  if (parsed.isComplete === true) {
    var markdown;
    try {
      markdown = await markdownBuilder.generateBrief(session);
    } catch (mdErr) {
      markdown = generateFallbackBrief(session);
    }
    await sessionManager.persistSession(sessionId, markdown);
    return {
      message: parsed.message,
      isComplete: true,
      turnCount: session.turnCount,
      coveredCategories: parsed.coveredCategories || [],
      markdown: markdown
    };
  }

  sessionManager.updateSession(sessionId, {
    clientName: parsed.clientName || session.clientName,
    coveredCategories: parsed.coveredCategories || session.coveredCategories,
    confidence: parsed.confidence || {}
  });

  return {
    message: parsed.message,
    isComplete: false,
    turnCount: session.turnCount,
    coveredCategories: parsed.coveredCategories || []
  };
}

module.exports = { startConversation, processMessage };
